<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Kevin Leonardo Anantha - Project Portfolio</title>
<link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Kevin Leonardo Anantha - Project Portfolio</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="project-k-n-s-addressbook"><a class="link" href="#project-k-n-s-addressbook">Project: K.N.S. AddressBook</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>K.N.S. AddressBook is a Java desktop address book application created by <strong>Team W11-B3</strong> during the course of <strong>CS2103T
Software Engineering</strong> in AY2017/8 Semester 1. This Portfolio details my major contributions to the project, and lists our other minor contributions as well.</p>
</div>
<div class="paragraph">
<p><strong>Code Contributed</strong>:
 [<a href="https://github.com/CS2103AUG2017-W11-B3/main/blob/master/collated/main/k-l-a.md">Functional Code</a>]
 [<a href="https://github.com/CS2103AUG2017-W11-B3/main/blob/master/collated/test/k-l-a.md">Test Code</a>]</p>
</div>
<div class="sect2">
<h3 id="enhancement-added-partial-finding"><a class="link" href="#enhancement-added-partial-finding">Enhancement Added: Partial Finding</a></h3>
<div class="sect3">
<h4 id="external-behavior"><a class="link" href="#external-behavior">External behavior</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
<div class="sect3">
<h4 id="partial-matching"><a class="link" href="#partial-matching">Partial Matching</a></h4>
<div class="paragraph">
<p>The Find command accepts partial matches by default.<br></p>
</div>
<div class="paragraph">
<p>Keywords <strong>will match</strong> entries if they are contained within those entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
However, vice-versa does not apply!
i.e. Entries <strong>will not match</strong> keywords if the entries are contained within the keywords.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>find mel</code><br>
Matches <code>Melissa</code> and <code>Amelia</code></p>
</li>
<li>
<p><code>find amelia</code><br>
Matches <code>Amelia</code> but not <code>Melissa</code> or <code>Mel</code></p>
</li>
<li>
<p><code>find leon</code><br>
Matches <code>Leonard</code> but not <code>Leo</code></p>
</li>
<li>
<p><code>find t/ frien</code><br>
Matches any person with a tag that contains <code>frien</code>, e.g. <code>Friends</code> or <code>BestFriends</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="justification"><a class="link" href="#justification">Justification</a></h4>
<div class="paragraph">
<p>Most people will likely not fully remember their contact details, so a partial find of some kind would be very beneficial
to have in the find command. Even if they do, a partial find can still be useful in reducing the actual number of characters
someone has to type, because they can type the keywords up to a point where they&#8217;re sure that it won&#8217;t match most contacts
other than the one they&#8217;re looking for. So, given that partial finding is more convenient for everyone, I decided that it
was more appropriate than exclusive matching.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation"><a class="link" href="#implementation">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partial-find"><a class="link" href="#partial-find">Partial Find</a></h3>
<div class="paragraph">
<p>The partial matching of the Find command is implemented by creating a method in the <code>StringUtil</code> class with the help of
the <code>regionMatches</code> method from the java <code>String</code> class.
It replaces the method for matching in all predicate classes that is used by the command.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Find command now only use partial matching and has lost the full matching functionality
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Previously, the method used for matching was implemented as such:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> containsWordIgnoreCase(<span class="predefined-type">String</span> sentence, <span class="predefined-type">String</span> word) {
        <span class="comment">// ...check and prepare arguments..</span>
        <span class="keyword">for</span> (<span class="predefined-type">String</span> wordInSentence: wordsInPreppedSentence) {
            <span class="keyword">if</span> (wordInSentence.equalsIgnoreCase(preppedWord)) {
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the <code>equalsIgnoreCase</code> method, the query word has to exactly match, ignoring case, the sentence word for the
method to return <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>A slightly modified version of the previous method is created to allow for partial matching as such:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"> <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> containsWordPartialIgnoreCase(<span class="predefined-type">String</span> sentence, <span class="predefined-type">String</span> word) {
        <span class="comment">//..check and prepare arguments..</span>
        <span class="keyword">return</span> preppedSentence.contains(preppedWord);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the <code>contains</code> method, the query word can now be a substring of the sentence word.
It also shortens the method, as there is no more need to check through word-by-word.</p>
</div>
<div class="paragraph">
<p>Afterwards, the use of the previous method in the Predicate classes in model
(<em>e.g.</em> <code>NameContainsKeywordsPredicate</code>) is replaced with the new method so that the Find command actually uses partial matching.</p>
</div>
<div class="sect3">
<h4 id="design-considerations"><a class="link" href="#design-considerations">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect:</strong> Exclusive use of partial matching.<br>
<strong>Alternative 1 (current choice):</strong> Find command exclusively uses partial matching.<br>
<strong>Pros:</strong> Simple implementation, doesn&#8217;t affect complexity from user&#8217;s perspective and easier for users to utilize Find
command.<br>
<strong>Cons:</strong> Users lose the ability to do full matching when it would be useful
(<em>e.g. a lot of people with similiar names</em>).<br>
<strong>Alternative 2:</strong> Give the option to toggle/use either partial matching or full matching<br>
<strong>Pros:</strong> More flexible and powerful.<br>
<strong>Cons:</strong> Requires more complicated syntax which can be confusing to new users, most use cases are already covered by
partial matching.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect:</strong> Type of partial matching<br>
<strong>Alternative 1 (current choice):</strong> Matches can be from anywhere in the word<br>
<strong>Pros:</strong> More intuitive way of searching, simpler to understand.<br>
<strong>Cons:</strong> Search results become less relevant for short keywords. (<em>Mitigated by sorting the results based on match position</em>)<br>
<strong>Alternative 2:</strong> Matches are required to be from the start of each word.<br>
<strong>Pros:</strong> Restricts the scope of search which increases relevancy but still giving enough flexibility for users.<br>
<strong>Cons:</strong> Can be unintuitive, less powerful.<br></p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="enhancement-added-find-by-tag"><a class="link" href="#enhancement-added-find-by-tag">Enhancement Added: Find by Tag</a></h3>
<div class="sect3">
<h4 id="external-behavior-2"><a class="link" href="#external-behavior-2">External behavior</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
<div class="sect3">
<h4 id="by-tag"><a class="link" href="#by-tag">By Tag</a></h4>
<div class="paragraph">
<p>To find by tag, you can use the prefix <code>t/</code>.<br></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When finding by tag, it will match person with any tag matching at least one of the keywords.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>find t/ family</code><br>
Returns any person with the tag <code>family</code></p>
</li>
<li>
<p><code>f t/ friends family colleague</code><br>
Returns any person with at least one of the tags <code>friends</code>, <code>family</code>, or <code>colleague</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="justification-2"><a class="link" href="#justification-2">Justification</a></h4>
<div class="paragraph">
<p>Similar with partial finding, there will be times where the <code>name</code> is the field that is forgotten by the user. In such
scenarios, without the ability to find by tags (or other fields), the user&#8217;s capability to locate a person will be
crippled, and alongside it, the usefulness of our application. So, I decided that a find by tag was necessary. The tag
prefix is used to indicate searching by tag as the user would be most familiar with it already, given that other
commands, such as <code>add</code> and <code>edit</code>, already uses such a format.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-2"><a class="link" href="#implementation-2">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark> <strong>written by Nadhira Salsabila</strong></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="find-by-all-field"><a class="link" href="#find-by-all-field">Find by All Field</a></h3>
<div class="paragraph">
<p>The find by all field feature is implemented by adding one argument, prefix of field that want to be searched, to the
<code>find</code> command parameter. If the user does not specify the prefix, the address book will automatically search the query
in the name field. The FindCommandParser will parse the input given by the user. The mechanism to find by each field is
implemented in &lt;field name&gt;ContainsKeywordPredicate class (i.e. NameContainsKeywordPredicate,
AddressContainsKeywordPredicate) inside Model component.</p>
</div>
<div class="sect3">
<h4 id="java-implementation"><a class="link" href="#java-implementation">Java Implementation</a></h4>
<div class="paragraph">
<p>The FindCommandParser is now able to parse the additional prefix argument, as shown in the code snippet below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> FindCommand parse(<span class="predefined-type">String</span> args) <span class="directive">throws</span> <span class="exception">ParseException</span> {
        <span class="comment">// make sure that the argument is valid</span>
        <span class="comment">// store the prefix inside String 'toSearch'</span>
        <span class="comment">// store the search query inside array of string 'keyword'</span>

        <span class="keyword">if</span> (toSearch.equals(PREFIX_TAG.getPrefix())) {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> TagListContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        } <span class="keyword">else</span> <span class="keyword">if</span> (toSearch.equals(PREFIX_PHONE.getPrefix())) {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> PhoneContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        } <span class="keyword">else</span> <span class="keyword">if</span> (toSearch.equals(PREFIX_EMAIL.getPrefix())) {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> EmailContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        } <span class="keyword">else</span> <span class="keyword">if</span> (toSearch.equals(PREFIX_ADDRESS.getPrefix())) {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> AddressContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        } <span class="keyword">else</span> <span class="keyword">if</span> (toSearch.equals(PREFIX_BIRTHDAY.getPrefix())) {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> BirthdayContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="keyword">new</span> FindCommand(<span class="keyword">new</span> NameContainsKeywordsPredicate(<span class="predefined-type">Arrays</span>.asList(keywords)));
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>After FindCommandParser parse the arguments, it will call the &lt;field name&gt;ContainsKeywordsPredicate class for each
respective field.</p>
</div>
<div class="paragraph">
<p>All contacts with partial matches will appear on the search result, implemented in the method below for phone field.
The method is similar for other field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">boolean</span> test(ReadOnlyPerson person) {
        <span class="keyword">return</span> keywords.stream().anyMatch(keyword -&gt; StringUtil
                .containsWordPartialIgnoreCase(person.getPhone().value, keyword));
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations-2"><a class="link" href="#design-considerations-2">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect:</strong> Implementation of find by all field<br>
<strong>Alternative 1 (current choice):</strong> Enables user to find by all field (name, phone, email, address, birthday, and
tag).<br>
<strong>Pros:</strong> Easier for user to find their contacts when the user does not remember their contact&#8217;s name, instead they
remember the contacts' details (such as address or birthday). This feature is useful for a broader range of purpose,
for example when the user wants to send a birthday wishes to their contacts, the user can easily find by using
birthday field.<br>
<strong>Cons:</strong> Need to type the prefix of the field that want to be searched.<br>
<strong>Alternative 2:</strong> Find by name only.<br>
<strong>Pros:</strong> Some people only remember their contact&#8217;s name, and find by all field feature might not be useful for them as
they don&#8217;t remember their contact&#8217;s details.<br>
<strong>Cons:</strong> User could not find their contact details when they do not remember their contact&#8217;s name.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect:</strong> Find result upon executing <code>find</code> command.<br>
<strong>Alternative 1 (current choice):</strong> All contacts with partial match with the find query will appear.<br>
<strong>Pros:</strong> With less restrictive requirement, users can find a broad range of contacts when they are searching using a
global keyword. For example, a user can find all their contacts who lived in "Clementi" when using this alternative.<br>
<strong>Cons:</strong> More contacts will appear on the find result, some of them might not be the target contact that the user
wants to find.<br>
<strong>Alternative 2:</strong> Only contacts with exact match will appear.<br>
<strong>Pros:</strong> Less contacts will appear on the find result, easier to find the exact person while searching for a single
person.<br>
<strong>Cons:</strong> It will be hard for a forgetful user to find their contacts as they may remember their contact details'
partially. This alternative is also more cumbersome when applied to find by address, as user need to type the full
address of their contact.</p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="enhancement-added-sorting"><a class="link" href="#enhancement-added-sorting">Enhancement Added : Sorting</a></h3>
<div class="sect3">
<h4 id="external-behavior-3"><a class="link" href="#external-behavior-3">External Behavior</a></h4>
<hr>
<div class="sect4">
<h5 id="find-auto-sort"><a class="link" href="#find-auto-sort">Find Auto-sort</a></h5>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When finding by name, the result will auto sort according to the position of the match. e.g. <code>find Bo</code> will list <code>Bo Alex</code> before <code>Holbo</code> and <code>Holbo</code> before <code>Alexander Bo</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
</div>
<div class="sect4">
<h5 id="sort-command"><a class="link" href="#sort-command">Sort Command</a></h5>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sorting-your-contact-list-code-sort-code"><a class="link" href="#sorting-your-contact-list-code-sort-code">Sorting your contact list: <code>sort</code></a></h3>
<div class="paragraph">
<p>If you want to view your current list in a better way, you can use the <code>sort</code> command to
sort the current list lexicographically by the given prefix, in the given order.<br></p>
</div>
<div class="paragraph">
<p>To sort the current list, you can use: <code>sort [PREFIX] [ORDER]</code><br></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Only the current list is sorted, there is currently no lasting sort on the whole address book.<br></p>
</li>
<li>
<p>ORDER can either be <code>asc</code> for ascending or <code>des</code> for descending. If ORDER is omitted, the list is still sorted ascendingly<br></p>
</li>
<li>
<p>PREFIX can be any prefix with the exception of <code>t/</code> and <code>v/</code>.<br></p>
</li>
<li>
<p>If PREFIX is omitted, the current list is sorted in the order of insertion. You can still reverse the order by using <code>des</code> without any prefix.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>list</code><br>
<code>sort des</code><br>
Sorts the list in reverse order of insertion (i.e. the previous list is now reversed)</p>
</li>
<li>
<p><code>find t/ friends</code><br>
<code>sort n/</code><br>
Sorts the resulting list from the <code>find</code> command by name, in ascending order.<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(i.e. the list is now a list of people who has a tag matching <code>friends</code>, sorted alphabetically by name.)</p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
<div class="sect3">
<h4 id="justification-3"><a class="link" href="#justification-3">Justification</a></h4>
<div class="paragraph">
<p>With the target audience in mind, I thought it was likely that there would sometimes be a scenario where the user wants
to view a relatively large <code>find</code> result. Given so, I decided to implement 2 kinds of sorting, one integrated into the <code>find</code>
command, and the other as a <code>sort</code> command, in order to maximize the ease at which the user can parse through the result
list. The Auto-Sort integrated into the <code>find</code> command will help users who wants to search for a person, but only remember a short
part of their name. The <code>sort</code> command will help users who want to organize their search results, in order to record them
for other purposes.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-3"><a class="link" href="#implementation-3">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sorting-viewable-list"><a class="link" href="#sorting-viewable-list">Sorting viewable list</a></h3>
<div class="paragraph">
<p>The <code>sort</code> command and auto-sorting of the <code>find</code> command is facilitated by a <code>SortedFilteredList</code> inside the <code>ModelManager</code> class. This list is created on top of
the <code>FilteredList</code> that is used to filter the contact list. A Comparator called <code>defaultSortOrder</code> was also created to as a
comparator to reset the sorted list to its default order. <code>ModelManager</code> was also modified to support updating the sorted list only,
and to always reset to default order whenever the filtered list is updated.</p>
</div>
<div class="paragraph">
<p>Commands that changes the viewable list without any sorting are implemented as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ListCommand</span> <span class="directive">extends</span> Command {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> CommandResult execure() {
        <span class="comment">// ... some logic ...</span>
        model.updateFilteredList(some predicate);
        <span class="comment">// ... more logic ...</span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whereas commands with sorting (e.g. <code>find</code>) is implemented as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">FindCommand</span> <span class="directive">extends</span> Command {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> CommandResult execute() {
        <span class="comment">// ... some logic ...</span>
        model.updateFilteredList(some predicate);
        model.updateSortedFilteredList(some comparator);
        <span class="comment">// ... more logic ...</span>
    }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="auto-sort-of-find-command"><a class="link" href="#auto-sort-of-find-command">Auto-Sort of Find Command</a></h4>
<div class="paragraph">
<p>The <code>find</code> command, when matching by name, sorts its resulting list by the earliest position of a match with a given keyword.<br>
This is implemented by creating a <code>earliestIndexOf</code> method in the <code>StringUtil</code> class, which takes in a sentence and a list of keywords, and returns the earliest starting index where a part of the sentence matches a keyword, or -1 if there are no match.</p>
</div>
<div class="paragraph">
<p>As an example, suppose the address book contains three people:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/SortListUnsorted.png" alt="SortListUnsorted" width="200">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.5.1.1: 3 People Listed in the PersonList</em></p>
</div>
<div class="paragraph">
<p>When a <code>find n/ i</code> command is executed, it will match all three of them (since all their names contains i),
and show them in this order:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/SortListSorted.png" alt="SortListSorted" width="200">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.5.1.1: 3 People Listed in the New Order</em></p>
</div>
<div class="paragraph">
<p>as M<em><strong>i</strong></em>chael has i in the 2nd position, Al<em><strong>i</strong></em>cia has an i in the 3rd position, and Dan<em><strong>i</strong></em>el has an i in
the 4th position.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations-3"><a class="link" href="#design-considerations-3">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect:</strong> Implementation of sorting<br>
<strong>Alternative 1 (current choice):</strong> Sort the viewable list only by creating a <code>SortedFilteredList</code><br>
<strong>Pros:</strong> Preserves the original order without additional changes, sort without worrying about changing the data.<br>
<strong>Cons:</strong> Harder to implement a permanent sort functionality.<br>
<strong>Alternative 2:</strong> Sort the data directly<br>
<strong>Pros:</strong> Easier to make a permanent sort.
<strong>Cons:</strong> Cannot go back to original order without additional changes. Harder to sort temporarily.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect:</strong> Type of sorting in <code>find</code><br>
<strong>Alternative 1 (current choice):</strong> Sort the resulting list of <code>find</code> by the earliest matching index.<br>
<strong>Pros:</strong> Make searching with short keywords more effective since the desired result is likely at the top.<br>
<strong>Cons:</strong> Can be unintuitive, especially since it&#8217;s only done when finding by name.<br>
<strong>Alternative 2:</strong> Show the resulting list in the default sort order.<br>
<strong>Pros:</strong> More intuitive. No need for extra code.<br>
<strong>Cons:</strong> Harder to find desired person when the result list is long.<br></p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect:</strong> Mechanism to create comparators<br>
<strong>Alternative 1 (current choice):</strong> <code>sort</code> and <code>find</code> uses separate method to create Comparator<br>
<strong>Pros:</strong> More flexible since each command can do a different kind of sorting.<br>
<strong>Cons:</strong> A lot of similar logic is copied to implement the methods individually.<br>
<strong>Alternative 2:</strong> Create a class or method that returns Comparators.<br>
<strong>Pros:</strong> Only implement once. Each sorting method now just need to call this method.<br>
<strong>Cons:</strong> Take longer to code. Need to allow access to private variables in predicate classes.<br></p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="enhancement-added-import-export-command"><a class="link" href="#enhancement-added-import-export-command">Enhancement Added : Import &amp; Export Command</a></h3>
<div class="sect3">
<h4 id="external-behavior-4"><a class="link" href="#external-behavior-4">External Behavior</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: User Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving-backing-up-your-data-code-export-code-or-code-ex-code"><a class="link" href="#saving-backing-up-your-data-code-export-code-or-code-ex-code">Saving/Backing up your data: <code>export</code> or <code>ex</code></a></h3>
<div class="paragraph">
<p>Exports current address book data to a file with the specified filename in the data folder.<br></p>
</div>
<div class="paragraph">
<p>While K.N.S provides automatic data saving, you can still manually back up your data using the <code>export</code> command.</p>
</div>
<div class="paragraph">
<p>To export your data, you should type:<br>
<code>export</code> or <code>ex</code> <code>FILENAME.xml</code><br>
where FILENAME is the name you want to give to the exported data.</p>
</div>
<div class="paragraph">
<p>This will export your current address book data into a file with the specified filename.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Exported data is saved in the <code>data</code> folder, which should be in the same folder as the application file, by default.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If a file with the filename you entered already exists in the <code>data</code> folder, it <em><strong>will be overwritten</strong></em> without warning!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>export backup.xml</code><br>
Exports your data in the <code>data</code> folder as <code>backup.xml</code><br></p>
</li>
<li>
<p><code>ex copy</code><br>
Fails and will prompt you to add a <code>.xml</code> to the end of the file name.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="importing-data-code-import-code-or-code-i-code"><a class="link" href="#importing-data-code-import-code-or-code-i-code">Importing data: <code>import</code> or <code>i</code></a></h3>
<div class="paragraph">
<p>Imports data from the file in the given filepath, and overwrite current address book data.<br></p>
</div>
<div class="paragraph">
<p>To import data from another application or your own backup data, you can use the <code>import</code> command with the format:<br>
<code>import</code> or <code>i FILEPATH</code><br>
where FILEPATH is the relative filepath of the data to be imported. (Usually in the <code>data</code> folder)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The data file to be imported does not have to be a <code>.xml</code> file, as long as the its contents are correctly formatted.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When you import data, you cannot get your old data back once you close the application.<br>
 (<em>you can still use <code>undo</code> if you haven&#8217;t</em>)<br>
It is recommended to backup using the <code>export</code> command first before importing.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>import data/backup.xml</code><br>
Imports the data in the file <code>backup.xml</code> in the <code>data</code> folder which should be located in the same folder as the application.<br></p>
</li>
<li>
<p><code>i copy</code><br>
Imports the data in the file <code>copy</code> which should be located at the same folder as the application.<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
<div class="sect3">
<h4 id="justification-4"><a class="link" href="#justification-4">Justification</a></h4>
<div class="paragraph">
<p>As the application provides automatic saving, I thought it was prudent to have a manual saving mechanism, in order for
users to defend against accidents that the <code>undo</code>/<code>redo</code> mechanism can&#8217;t fix, such as accidentally closing the application
without realizing a mistaken delete. It also provides a way for less savvy users who does not know how to manually back
up and import their data to do so.<br>
Keeping that in mind, the current behavior mainly supports backing up your data and
loading them afterwards, instead of being able to switch your address book to work on another one, since that is not the
intended purpose.</p>
</div>
</div>
<div class="sect3">
<h4 id="implementation-4"><a class="link" href="#implementation-4">Implementation</a></h4>
<hr>
<div class="paragraph">
<p><mark>Start of Extract [from: Developer Guide]</mark></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="import-export-mechanism"><a class="link" href="#import-export-mechanism">Import &amp; Export Mechanism</a></h3>
<div class="paragraph">
<p>The import and export mechanism is implemented using the <code>XmlAddressBookStorage</code> class. It allows for the manual saving and loading of the
address book data, aside from the default initial loading and automatic saving, by using the <code>export</code> and <code>import</code> command.</p>
</div>
<div class="paragraph">
<p>Import only changes the address book&#8217;s data, and does not change the user preference. Notably, it does not change
the default file which the application automatically saves to, which is <code>addressbook.xml</code>. Instead, it overwrites the current data with
the data in the given filepath, provided it is a valid address book data.</p>
</div>
<div class="paragraph">
<p>The following shows the dependencies of both <code>ImportCommand</code> and <code>ExportCommand</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ImportExportAssocDiagram.png" alt="ImportExportAssocDiagram" width="600">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.4.1: Import/Export Association Diagram</em></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the <code>XmlAddressBookStorage</code> fails to read or write to file, an <code>Exception</code> will be thrown.
The same will happen if the file contains persons with illegal values. (e.g. empty name)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose the user has just initialized the application, and the <code>data</code> folder is empty.</p>
</div>
<div class="paragraph">
<p>The user makes some changes to the data (e.g. using <code>clear</code> and <code>add</code> to clear away the sample and add their own contacts) which
saves the data in the <code>data</code> folder as <code>addressbook.xml</code> automatically.</p>
</div>
<div class="paragraph">
<p>Then, without altering the data any further, the user decides to save a manual backup using a <code>export backup.xml</code> command.
This will create a <code>backup.xml</code> file in the <code>data</code> folder, which at this point is equivalent to the <code>addressbook.xml</code>.</p>
</div>
<div class="paragraph">
<p>As the user continues to alter the data, the <code>addressbook.xml</code> file will keep changing, and will be different than the <code>backup.xml</code>
file.<br>
The user then decides that they want to return the addressbook to their backup version using a <code>import data/backup.xml</code> command.<br>
This will overwrite the current data with the data in <code>backup.xml</code>, making it once again equivalent to <code>addressbook.xml</code></p>
</div>
<div class="sect3">
<h4 id="sequence-diagram"><a class="link" href="#sequence-diagram">Sequence Diagram</a></h4>
<div class="paragraph">
<p>The sequence diagram for the command <code>export a.xml</code> is the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ImportExportSequenceDiagram.png" alt="ImportExportSequenceDiagram" width="800">
</div>
</div>
<div class="paragraph">
<p><em>Figure 5.4.1.1: Sequence Diagram for Export Command</em></p>
</div>
<div class="paragraph">
<p>An <code>import</code> command would be similar, except that it creates a <code>XmlAddressBookStorage</code> object first, calls the <code>readAddressBook</code> method, and then
calls the <code>resetData</code> method from the <code>Model</code> object.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations-4"><a class="link" href="#design-considerations-4">Design Considerations</a></h4>
<div class="paragraph">
<p><strong>Aspect</strong>: How import works<br>
<strong>Alternative 1(current choice):</strong> Overwrite the current address book with the data from the given file.<br>
<strong>Pros:</strong> Easier implementation, data in the given file is preserved.<br>
<strong>Cons:</strong> Loses the current address book data, which cannot be recovered if the address book is closed. (Can still be recovered with undo if it has not been closed since the import yet)<br>
<strong>Alternative 2:</strong> Switch the file that the address book uses to the given file, and save all changes to that file<br>
<strong>Pros:</strong> Allows for easier use of multiple saved files. The data in the current (before import) file is preserved.<br>
<strong>Cons:</strong> Harder implementation, does not provide an easy way to import backups, since all changes are saved to the given file.<br></p>
</div>
<hr>
<div class="paragraph">
<p><strong>Aspect</strong>: Scope of data to export and import<br>
<strong>Alternative 1(current choice):</strong> Exports and imports only the address book data, excluding pictures and user preferences.<br>
<strong>Pros:</strong> Can use the current <code>XmlAddressBookStorage</code> class to read and write. Only read and write a single file.<br>
<strong>Cons:</strong> Excluding pictures means user have to manually backup pictures, otherwise address book is incomplete (no avatar).<br>
<strong>Alternative 2:</strong> Include pictures and/or user preferences<br>
<strong>Pros:</strong> More complete data storage.<br>
<strong>Cons:</strong> Higher probability of accidentally overwriting files if the user is not careful.<br></p>
</div>
<div class="paragraph">
<p><mark>End of Extract</mark></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="enhancement-proposed-boolean-searching"><a class="link" href="#enhancement-proposed-boolean-searching">Enhancement Proposed: Boolean Searching</a></h3>
<div class="sect3">
<h4 id="justification-5"><a class="link" href="#justification-5">Justification</a></h4>
<div class="paragraph">
<p>Given the target audience of our product, it is plausible that they would need to find people who matches certain
criteria without having a specific person in mind. For example, they might need to find everyone who are clients but not
currently overseas. In current form, there is no way for them to do this easily.<br>
Boolean searching will allow them to search using AND and NOT keywords to enable a much easier searching experience.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="other-contributions"><a class="link" href="#other-contributions">Other Contributions</a></h3>
<div class="ulist">
<ul>
<li>
<p><strong>Modified <code>add</code> to accept missing prefixes other than name</strong></p>
<div class="ulist">
<ul>
<li>
<p>Each missing prefix will be shown with a default value to indicate their absence</p>
</li>
<li>
<p>Pull Request : <a href="https://github.com/CS2103AUG2017-W11-B3/main/pull/39">#39</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Set up various project tools, such as :</strong></p>
<div class="ulist">
<ul>
<li>
<p>Appveyor and Coveralls configuration for github repo.</p>
</li>
<li>
<p>Github-pages website, via Travis CI.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Created the table for command cheat sheet in the user guide</strong></p>
<div class="ulist">
<ul>
<li>
<p>Pull Request : <a href="https://github.com/CS2103AUG2017-W11-B3/main/pull/63">#63</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-11-13 12:57:06 +00:00
</div>
</div>
</body>
</html>